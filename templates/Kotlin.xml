<templateSet group="Kotlin">
  <template name="columnprovider" value="import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import com.dapulse.dapulse.R&#10;import com.dapulse.dapulse.refactor.layers.columns.BoardId&#10;import com.dapulse.dapulse.refactor.layers.columns.ColumnService&#10;import com.dapulse.dapulse.refactor.layers.columns.IColumnCenterHandler&#10;import com.dapulse.dapulse.refactor.layers.columns.PulseId&#10;import com.dapulse.dapulse.refactor.layers.data.board.*&#10;import com.dapulse.dapulse.refactor.layers.data.board.columns_view.*&#10;import com.google.gson.JsonElement&#10;import com.google.gson.JsonObject&#10;import dagger.Binds&#10;import dagger.Module&#10;import dagger.Subcomponent&#10;import dagger.android.AndroidInjector&#10;import dagger.multibindings.ClassKey&#10;import dagger.multibindings.IntoMap&#10;&#10;//TODO don not forget to add this new column provider into SupportedTypes and remove this comment afterward&#10;class $COLUMN_NAME$ColumnProvider : IColumnProvider {&#10;    override fun getDataHandler() = $COLUMN_NAME$ColumnDataHandler()&#10;&#10;    override fun getColumn(&#10;            boardId: BoardId,&#10;            columnEntity: ColumnEntity,&#10;            values: Map&lt;PulseId, ColumnValueEntity?&gt;,&#10;            boardEntity: BoardEntity&#10;    ) = $COLUMN_NAME$ColumnService(boardId, columnEntity, values, boardEntity)&#10;&#10;    override fun getViewHandler() = $COLUMN_NAME$ColumnViewHandler()&#10;&#10;    override fun getColumnCenterHandler() = $COLUMN_NAME$ColumnCenterHandler()&#10;}&#10;&#10;class $COLUMN_NAME$ColumnParser : IColumnParser() {&#10;    override fun parseColumnData(jsonObject: JsonObject): ColumnData? = dataParser.fromJson(jsonObject, CommonColumnData::class.java)&#10;&#10;    override fun parseColumnValueData(jsonElement: JsonElement): ColumnValueData? = null&#10;&#10;//    if the column have settings this is the place to parse them, if you don't need just delete&#10;//    override fun parseColumnSettings(settings: JsonElement): ColumnSettings? {&#10;//        return super.parseColumnSettings(settings)&#10;//    }&#10;}&#10;&#10;class $COLUMN_NAME$ColumnDataHandler : IColumnDataHandler {&#10;    override fun getParser() = $COLUMN_NAME$ColumnParser()&#10;&#10;    override fun getColumnValueEntity(columnValueData: ColumnValueData?, columnValueId: ColumnValueId): ColumnValueEntity? = null&#10;&#10;    override fun getColumnValueFromEntity(entity: ColumnValueEntity): ColumnValueData? = null&#10;&#10;//    this is used to get data that specific to the column, for example, to pass the settings to the column entity, if you don't need just delete&#10;//    override fun getColumnSpecificData(columnData: ColumnData, columnSettings: ColumnSettings?): ColumnSpecificData? {&#10;//        return super.getColumnSpecificData(columnData, columnSettings)&#10;//    }&#10;&#10;//    if you want to change the column setting you need to implement this function in order to get column with the new settings, if you don't need just delete&#10;//    override fun getColumnDataFromEntityAndNewSettings(columnEntity: ColumnEntity, newSettings: ColumnSpecificData, dataParser: IDataParser): ColumnData? {&#10;//        return super.getColumnDataFromEntityAndNewSettings(columnEntity, newSettings, dataParser)&#10;//    }&#10;}&#10;&#10;class $COLUMN_NAME$ColumnService(boardId: BoardId,&#10;                          columnEntity: ColumnEntity,&#10;                          values: Map&lt;PulseId, ColumnValueEntity?&gt;,&#10;                          boardEntity: BoardEntity&#10;) : ColumnService(boardId, columnEntity, values, boardEntity) {&#10;&#10;//  create specific data for you column, it will be forward tot he UI when bind new data&#10;//    override fun getColumnValueSpecificViewData(pulseId: PulseId): ColumnValueSpecificViewData? {&#10;//        return super.getColumnValueSpecificViewData(pulseId)&#10;//    }&#10;&#10;//  if you do not want to show the column in specific placement&#10;//    override fun shouldShownInPlacement(placement: ColumnPlacement): Boolean {&#10;//        return super.shouldShownInPlacement(placement)&#10;//    }&#10;&#10;//  create specific data for you column's footer, it will be forward tot he UI when bind new data&#10;//    override fun getSummarySpecificViewDataForSectionId(sectionId: String): ColumnValueSpecificViewData? {&#10;//        return super.getSummarySpecificViewDataForSectionId(sectionId)&#10;//    }&#10;&#10;// if you have special title requirement&#10;//    override fun getTitleForSectionIdAndPlacement(sectionId: String, placement: ColumnPlacement): String {&#10;//        return super.getTitleForSectionIdAndPlacement(sectionId, placement)&#10;//    }&#10;&#10;// Does this column's header have any special text size requirement&#10;//    override fun getHeaderTitleSizeForPlacement(placement: ColumnPlacement): Float? {&#10;//        return super.getHeaderTitleSizeForPlacement(placement)&#10;//    }&#10;&#10;// Does this column's header have any special styling requirement&#10;//    override fun getHeaderTitleColorForSectionIdAndPlacement(sectionId: String, placement: ColumnPlacement): Int? {&#10;//        return super.getHeaderTitleColorForSectionIdAndPlacement(sectionId, placement)&#10;//    }&#10;&#10;// if the column should participate the formula party return here the value for the formula&#10;//    override fun getFormulaValue(pulseId: PulseId): String? {&#10;//        return super.getFormulaValue(pulseId)&#10;//    }&#10;&#10;// if you need to change the gravity of the title&#10;//    override fun shouldAlignToStart(): Boolean {&#10;//        return super.shouldAlignToStart()&#10;//    }&#10;&#10;// Sould this column's header show the edit popup when clicked (default: true)&#10;//    override fun shouldShowHeaderOption(): Boolean {&#10;//        return super.shouldShowHeaderOption()&#10;//    }&#10;&#10;}&#10;&#10;class $COLUMN_NAME$ColumnViewHandler : IColumnViewHandler() {&#10;    private lateinit var rootView : View&#10;    override fun createView(container: ViewGroup, placement: ColumnPlacement): View {&#10;        rootView = LayoutInflater.from(container.context).inflate(R.layout.$COLUMN_VIEW_MODE_LAYOUT$, container, false)&#10;        return rootView&#10;    }&#10;&#10;    override fun bindDataView(viewData: ColumnValueViewData, scaleFactor: Float) {&#10;&#10;    }&#10;    &#10;//  if the column support footer here you will bind the data for the summary view&#10;//    override fun bindSummaryData(viewData: ColumnValueViewData, scaleFactor: Float) {&#10;//        super.bindSummaryData(viewData, scaleFactor)&#10;//    }&#10;&#10;//  if you need to be inform on when the column have been clicked use this function&#10;//    override fun showEdit(viewData: ColumnValueViewData) {&#10;//        super.showEdit(viewData)&#10;//    }&#10;&#10;//  if you need to be inform on when the column footer have been clicked use this function&#10;//    override fun showSummaryEdit(viewData: ColumnValueViewData) {&#10;//        super.showSummaryEdit(viewData)&#10;//    }&#10;&#10;//  use this function to create footer cell&#10;//    override fun createSummaryView(container: ViewGroup, placement: ColumnPlacement): View? {&#10;//        return super.createSummaryView(container, placement)&#10;//    }&#10;&#10;//  if isHandlingClicks return true this is the  callback  to handle the clicks by yourself&#10;//    override fun handleClicks(viewData: ColumnValueViewData, listener: ColumnValueActionsListener) {&#10;//        super.handleClicks(viewData, listener)&#10;//    }&#10;&#10;//  if you need to handle click by yourself return here true, otherwise just delete&#10;//    override fun isHandlingClicks(): Boolean {&#10;//        return super.isHandlingClicks()&#10;//    }&#10;&#10;// if you have specific width requirement return it from here&#10;//    override fun getWidthForPlacement(placement: ColumnPlacement, resource: Resources): Int {&#10;//        return super.getWidthForPlacement(placement, resource)&#10;//    }&#10;&#10;// if you have specific height requirement return it from here&#10;//    override fun getHeightForPlacement(placement: ColumnPlacement, resource: Resources): Int {&#10;//        return super.getHeightForPlacement(placement, resource)&#10;//    }&#10;}&#10;&#10;class $COLUMN_NAME$ColumnCenterHandler : IColumnCenterHandler {&#10;    override fun getIcon(): Int? = R.drawable.$COLUMN_CENTER_ICON$&#10;    &#10;//  if the column should be featured at the column center return here the configuration, if you don't need just delete&#10;//    override fun getFeatureItemConfig(): FeaturedItemConfig? {&#10;//        return super.getFeatureItemConfig()&#10;//    }&#10;}&#10;&#10;// TODO do not forget to add $COLUMN_NAME$ColumnViewHandlerSubcomponentModule to ColumnsViewInjectors's includes list and remove this comment afterward&#10;@Module(subcomponents = [$COLUMN_NAME$ColumnViewHandlerSubcomponentModule.$COLUMN_NAME$ColumnViewHandlerSubcomponent::class])&#10;abstract class $COLUMN_NAME$ColumnViewHandlerSubcomponentModule {&#10;&#10;    @Binds&#10;    @IntoMap&#10;    @ClassKey($COLUMN_NAME$ColumnViewHandler::class)&#10;    internal abstract fun bindAndroidInjectorFactory(&#10;            builder: $COLUMN_NAME$ColumnViewHandlerSubcomponent.Builder): AndroidInjector.Factory&lt;*&gt;&#10;&#10;    @Subcomponent(modules = [CommonColumnViewModule::class])&#10;    interface $COLUMN_NAME$ColumnViewHandlerSubcomponent : AndroidInjector&lt;$COLUMN_NAME$ColumnViewHandler&gt; {&#10;        @Subcomponent.Builder&#10;        abstract class Builder : AndroidInjector.Builder&lt;$COLUMN_NAME$ColumnViewHandler&gt;()&#10;    }&#10;}" description="add new column provider" toReformat="true" toShortenFQNames="true">
    <variable name="COLUMN_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="COLUMN_VIEW_MODE_LAYOUT" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="COLUMN_CENTER_ICON" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN_TOPLEVEL" value="true" />
    </context>
  </template>
  <template name="boardview" value="import android.content.Context&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.FrameLayout&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProviders&#10;import com.dapulse.dapulse.R&#10;import com.dapulse.dapulse.refactor.layers.board_views.BoardViewToHostViewIsReadyEvent&#10;import com.dapulse.dapulse.refactor.layers.board_views.BoardViewsViewModel&#10;import com.dapulse.dapulse.refactor.layers.columns.BoardId&#10;import com.dapulse.dapulse.refactor.layers.columns.ColumnService&#10;import com.dapulse.dapulse.refactor.layers.columns.status.StatusColumnService&#10;import com.dapulse.dapulse.refactor.layers.columns.status.StatusColumnViewData&#10;import com.dapulse.dapulse.refactor.layers.data.AutoCloseableLifeCycleAware&#10;import com.dapulse.dapulse.refactor.layers.data.board.BoardQueryResult&#10;import com.dapulse.dapulse.refactor.layers.data.board.GroupBy&#10;import com.dapulse.dapulse.refactor.layers.data.board.GroupByInfo&#10;import com.dapulse.dapulse.refactor.layers.data.board.ICrossBoardComposite&#10;import com.dapulse.dapulse.refactor.layers.data.board.columns_view.OpenGallery&#10;import com.dapulse.dapulse.refactor.layers.data.board.columns_view.PulseInfo&#10;import com.dapulse.dapulse.refactor.layers.data.board.mailBox.IMailBox&#10;import com.dapulse.dapulse.refactor.layers.data.board.mailBox.MailBox&#10;import com.dapulse.dapulse.refactor.tools.AppPerformanceMonitor&#10;import com.dapulse.dapulse.refactor.tools.db.MondayDatabase&#10;import com.dapulse.dapulse.refactor.tools.featureFlag.FeatureFlag&#10;import com.monday.boardViews.*&#10;import com.monday.boardViews.kanbanView.IStatusProvider&#10;import com.monday.core.BatteryWidget&#10;import com.monday.core.IOTaskRunner&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.android.ContributesAndroidInjector&#10;import dagger.android.support.AndroidSupportInjection&#10;import kotlinx.android.synthetic.main.item_calendar_cell.*&#10;import java.util.*&#10;import javax.inject.Inject&#10;&#10;// TODO add $BOARD_VIEW$BoardViewFragmentModule::class to the module's list of the method bindBoardActivity&#10;// TODO add $BOARD_VIEW$($BOARD_VIEW$BoardViewProvider()) to BoardViewType enum&#10;// TODO add $BOARD_VIEW$_BOARD_VIEW_DEBUG(&quot;false&quot;) to RemoteConfigKey enum&#10;// TODO add $BOARD_VIEW$_VIEW to FeatureFlag enum&#10;// TODO add FeatureFlag.$BOARD_VIEW$_VIEW -&gt; { RemoteConfigKey.$BOARD_VIEW$_BOARD_VIEW_DEBUG } to method getStringValue of FeatureFlagService&#10;// TODO add FeatureFlag.$BOARD_VIEW$_VIEW -&gt; { remoteConfig.isEnabled(RemoteConfigKey.$BOARD_VIEW$_BOARD_VIEW_DEBUG) } to method isEnabled of FeatureFlagService&#10;// TODO add $BOARD_VIEW$_VIEW(&quot;$BOARD_VIEW$_view&quot;) to AppPerformanceMonitor.Component enum &#10;&#10;class $BOARD_VIEW$BoardViewProvider : IBoardViewProvider {&#10;&#10;    // This method provides the icon adn title that will be display in the board view picker&#10;    override fun getPickerInfo(): BoardViewPickerInfo {&#10;        return BoardViewPickerInfo(R.drawable.ic_icon_list, R.string.board_view_board_as_list_title, true)&#10;    }&#10;&#10;    // In case that the view depend on specific column and the column is missing, this method provides&#10;    // the icon, text and column type that will appear in the board view picker in the &quot;add column&quot; section,&#10;    // return here null means that the view is not depended on any specific column&#10;    override fun getPickerAddColumnInfo(existColumnServicesList: List&lt;ColumnService&gt;): BoardViewPickerAddColumnInfo? {&#10;        return null&#10;    }&#10;&#10;    // This method provides the fragment of the board view&#10;    override fun getFragment(): BoardViewFragment {&#10;        return $BOARD_VIEW$BoardViewFragment()&#10;    }&#10;&#10;    override fun getBoardViewTag(): String {&#10;        return &quot;$BOARD_VIEW$BoardViewFragment&quot;&#10;    }&#10;&#10;    // this will determine which action available in the Activity's FAB menu, if you want to get enable&#10;    // any action please see BoardViewsViewModel to look for the right live data to observe&#10;    override fun getHostConfiguration(): BoardViewHostConfiguration {&#10;        return BoardViewHostConfiguration(enableAddItem = false, enableAddColumn = false, enableAddGroup = false)&#10;    }&#10;&#10;    // this method gets the feature flag for the new board view, make sure to follow TODOs in order to &#10;    // add the new view to feature flag and to remote config&#10;    override fun getFeatureFlag(): FeatureFlag? {&#10;        return FeatureFlag.$BOARD_VIEW$_VIEW&#10;    }&#10;&#10;    // this method configure the board view navigation header, if you don't need it just return null&#10;    // the string resource in the text that will appear in the right action button&#10;    override fun getBoardViewInfoConfiguration(): BoardViewInfoConfiguration? {&#10;        return BoardViewInfoConfiguration(R.string.today)&#10;    }&#10;&#10;    // this method help to send performance events, make sure to follow TODOs in order to add the new&#10;    // component to AppPerformanceMonitor&#10;    override fun getPerformanceMonitorComponent(): AppPerformanceMonitor.Component {&#10;        return AppPerformanceMonitor.Component.$BOARD_VIEW$_VIEW&#10;    }&#10;&#10;    // this method configure what we showing the settings of the board view&#10;    // isSingleSelectedColumn - set whether the setting will be in single/multiple selection mode&#10;    // canShowColumnPredicate - set the list of columns that might be selected&#10;    // canPairColumnPredicate - set the list of columns that might be  connected, return false will leave empty list&#10;    override fun getBoardViewSettingsConfiguration(): BoardViewSettingsConfiguration? {&#10;        val canShowColumnPredictor: (ColumnService) -&gt; Boolean = { columnService -&gt; columnService is IStatusProvider }&#10;        val canPairColumnPredictor: (ColumnService) -&gt; Boolean = { false }&#10;        return BoardViewSettingsConfiguration(&#10;                isSingleSelectedColumn = false,&#10;                canShowColumnPredicate = canShowColumnPredictor,&#10;                canPairColumnPredicate = canPairColumnPredictor&#10;        )&#10;    }&#10;&#10;    // this method will hold the cross board configuration settings&#10;    override fun getCrossBoardCompositeConfiguration(): CrossBoardCompositeConfiguration {&#10;        return CrossBoardCompositeConfiguration(GroupBy.STATUS, true)&#10;    }&#10;}&#10;&#10;@Module&#10;abstract class $BOARD_VIEW$BoardViewFragmentModule {&#10;    @ContributesAndroidInjector(modules = [$BOARD_VIEW$BoardViewModule::class])&#10;    abstract fun bind$BOARD_VIEW$BoardViewFragment() : $BOARD_VIEW$BoardViewFragment&#10;&#10;    @Module&#10;    class $BOARD_VIEW$BoardViewModule {&#10;        @Provides&#10;        fun providePresenter(&#10;                fragment: $BOARD_VIEW$BoardViewFragment,&#10;                crossBoardComposite: ICrossBoardComposite,&#10;                mondayDatabase: MondayDatabase&#10;        ) : I$BOARD_VIEW$BoardViewPresenter {&#10;            val boardId = fragment.arguments?.getLong(BOARD_ID, 1L) ?: 1L&#10;            val viewModel = ViewModelProviders.of(fragment).get($BOARD_VIEW$BoardViewViewModel::class.java)&#10;            // BoardViewsViewModel is common to all board views and board activity so it must be&#10;            // on the activity&#10;            val boardViewsViewModel = ViewModelProviders.of(fragment.activity!!).get(BoardViewsViewModel::class.java)&#10;            val autoCloseable = AutoCloseableLifeCycleAware()&#10;            fragment.lifecycle.addObserver(autoCloseable)&#10;            val mailBox = MailBox&lt;$BOARD_VIEW$BoardViewModelMessage&gt;()&#10;            autoCloseable.closeableList.add(mailBox)&#10;            val model = $BOARD_VIEW$BoardViewModel(&#10;                    crossBoardComposite = crossBoardComposite,&#10;                    mailBox = mailBox,&#10;                    autoCloseable = autoCloseable,&#10;                    boardId = boardId,&#10;                    crossBoardCompositeConfigure = getCrossBoardCompositeConfigure(mondayDatabase, crossBoardComposite, boardId)&#10;            )&#10;            return $BOARD_VIEW$BoardViewPresenter(viewModel, boardViewsViewModel, model)&#10;        }&#10;        &#10;        private fun getCrossBoardCompositeConfigure(&#10;                mondayDatabase: MondayDatabase,&#10;                crossBoardComposite: ICrossBoardComposite,&#10;                boardId: BoardId&#10;        ) : IBoardViewsCrossBoardCompositeConfigure {&#10;            return BoardViewsCrossBoardCompositeConfigure(&#10;                    crossBoardComposite = crossBoardComposite,&#10;                    boardId = boardId,&#10;                    boardViewType = BoardViewType.$BOARD_VIEW$,&#10;                    mondayDatabase = mondayDatabase,&#10;                    taskRunner = IOTaskRunner())&#10;        }&#10;    }&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewFragment : BoardViewFragment() {&#10;&#10;    @Inject&#10;    lateinit var presenter: I$BOARD_VIEW$BoardViewPresenter&#10;&#10;    override fun onAttach(context: Context) {&#10;        AndroidSupportInjection.inject(this)&#10;        super.onAttach(context)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val frameLayout = FrameLayout(context!!)&#10;        frameLayout.setBackgroundColor(ContextCompat.getColor(context!!, R.color.da_white))&#10;        val battery = BatteryWidget(frameLayout.context)&#10;        val layoutParams = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 300)&#10;        layoutParams.setMargins(20, 0, 20, 0)&#10;        battery.layoutParams = layoutParams&#10;        battery.id = R.id.batteryBar&#10;        frameLayout.addView(battery)&#10;        return frameLayout&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        batteryBar.setOnClickListener {&#10;            presenter.onItemClick()&#10;        }&#10;        presenter.observe$BOARD_VIEW$ViewData(lifecycle) {&#10;            batteryBar.updateColorsCount(it.colorsCount)&#10;        }&#10;        presenter.loadData()&#10;    }&#10;}&#10;&#10;data class $BOARD_VIEW$ViewData(&#10;        val colorsCount: Map&lt;Int, Int&gt;,&#10;        val pulsesInfo: List&lt;PulseInfo&gt;&#10;)&#10;&#10;interface I$BOARD_VIEW$BoardViewViewObservers {&#10;    fun observe$BOARD_VIEW$ViewData(lifecycle: Lifecycle, observer: ($BOARD_VIEW$ViewData) -&gt; Unit)&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewViewModel : ViewModel(), I$BOARD_VIEW$BoardViewViewObservers {&#10;    private val viewDataLiveData = MutableLiveData&lt;$BOARD_VIEW$ViewData&gt;()&#10;&#10;    val currentViewData: $BOARD_VIEW$ViewData? get() = viewDataLiveData.value&#10;&#10;    override fun observe$BOARD_VIEW$ViewData(lifecycle: Lifecycle, observer: ($BOARD_VIEW$ViewData) -&gt; Unit) {&#10;        viewDataLiveData.observe({lifecycle}) {&#10;            it?.let(observer)&#10;        }&#10;    }&#10;&#10;    fun update$BOARD_VIEW$ViewData(viewData: $BOARD_VIEW$ViewData) {&#10;        viewDataLiveData.postValue(viewData)&#10;    }&#10;}&#10;&#10;interface I$BOARD_VIEW$BoardViewPresenter : I$BOARD_VIEW$BoardViewViewObservers {&#10;    fun loadData()&#10;    fun onItemClick()&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewPresenter(&#10;        private val viewModel: $BOARD_VIEW$BoardViewViewModel,&#10;        private val boardViewsViewModel: BoardViewsViewModel,&#10;        private val model: I$BOARD_VIEW$BoardViewModel&#10;) : I$BOARD_VIEW$BoardViewPresenter, I$BOARD_VIEW$BoardViewViewObservers by viewModel {&#10;&#10;    override fun loadData() {&#10;        model.observeNameColumn { info -&gt;&#10;            // set board view is ready when the board view has all data that it need in order to send&#10;            // view data, on first load of board activity loader will be shown until sending this event&#10;            if (viewModel.currentViewData == null) {&#10;                boardViewsViewModel.setBoardViewToHostEvent(BoardViewToHostViewIsReadyEvent(BoardViewType.$BOARD_VIEW$))&#10;            }&#10;&#10;            val colorToCountMap = mutableMapOf&lt;Int, Int&gt;()&#10;            info.pulses.forEach {&#10;                val viewData = info.pulseIdToStatusColumnServiceMap[it.columnId]?.getColumnValueViewData(it.pulseId)&#10;                viewData?.getSpecificViewData&lt;StatusColumnViewData&gt;()?.color?.let { color -&gt;&#10;                    colorToCountMap[color] = (colorToCountMap[color] ?: 0) + 1&#10;                }&#10;            }&#10;            viewModel.update$BOARD_VIEW$ViewData($BOARD_VIEW$ViewData(colorToCountMap, info.pulses.map { PulseInfo(it.pulseId, it.columnId) }))&#10;        }&#10;    }&#10;    &#10;    override fun onItemClick() {&#10;        viewModel.currentViewData?.pulsesInfo?.firstOrNull()?.let {&#10;            val openGallery = OpenGallery(it.pulseId, BoardViewType.$BOARD_VIEW$.name.toLowerCase(Locale.getDefault()))&#10;            boardViewsViewModel.setOpenItem(openGallery)&#10;        }&#10;    }&#10;}&#10;&#10;data class $BOARD_VIEW$Info(&#10;        val pulseIdToStatusColumnServiceMap: Map&lt;String, StatusColumnService?&gt;,&#10;        val pulses: List&lt;GroupByInfo&gt;&#10;)&#10;&#10;interface I$BOARD_VIEW$BoardViewModel {&#10;    fun observeNameColumn(observer: ($BOARD_VIEW$Info) -&gt; Unit)&#10;}&#10;&#10;// if you need to save state in the model it might be dangerous since the model's code will called&#10;// from different thread, MailBox is synchronization mean for access the state, here we define the &#10;// messages that the mail box can get &#10;sealed class $BOARD_VIEW$BoardViewModelMessage&#10;data class $BOARD_VIEW$BoardViewModelMessageBoardQueryResult(val queryResult: BoardQueryResult) : $BOARD_VIEW$BoardViewModelMessage()&#10;&#10;class $BOARD_VIEW$BoardViewModel(&#10;        private val crossBoardComposite: ICrossBoardComposite,&#10;        private val mailBox: IMailBox&lt;$BOARD_VIEW$BoardViewModelMessage&gt;,&#10;        private val autoCloseable: AutoCloseableLifeCycleAware,&#10;        private val boardId: BoardId,&#10;        crossBoardCompositeConfigure: IBoardViewsCrossBoardCompositeConfigure&#10;) : I$BOARD_VIEW$BoardViewModel, BaseBoardViewModel(crossBoardCompositeConfigure) {&#10;&#10;    private var nameColumnObservation: (($BOARD_VIEW$Info) -&gt; Unit)? = null&#10;    private var queryResult: BoardQueryResult?  = null&#10;&#10;    init {&#10;        mailBox.startReceiveMail { message -&gt;&#10;            when (message) {&#10;                is $BOARD_VIEW$BoardViewModelMessageBoardQueryResult  -&gt; handleUpdateBoardQueryResult(message.queryResult)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun observeNameColumn(observer: ($BOARD_VIEW$Info) -&gt; Unit) {&#10;        nameColumnObservation = observer&#10;        val observation = crossBoardComposite.observeBoardQueryResult { queryResult -&gt;&#10;            queryResult.resultMap[boardId]?.let { boardQueryResult -&gt;&#10;                mailBox.sendNewMail($BOARD_VIEW$BoardViewModelMessageBoardQueryResult(boardQueryResult))&#10;            }&#10;        }&#10;        // we want to close the observation to the cross board composite when the view will be&#10;        // closed, by register it to auto closeable the observation will close for us when needed&#10;        autoCloseable.closeableList.add(observation)&#10;    }&#10;    &#10;    private fun handleUpdateBoardQueryResult(boardQueryResult: BoardQueryResult) {&#10;        this.queryResult  = boardQueryResult&#10;        notifyObserver(boardQueryResult)&#10;    }&#10;&#10;    private fun notifyObserver(boardQueryResult: BoardQueryResult) {&#10;        val columnIdToColumnServiceMap = boardQueryResult.columnsList.associateBy { it.id }&#10;        val pulseIdToStatusColumnServiceMap = mutableMapOf&lt;String, StatusColumnService?&gt;()&#10;        boardQueryResult.meta?.pivotColumnsList?.forEach { pivotColumnsInfo -&gt;&#10;            pulseIdToStatusColumnServiceMap[pivotColumnsInfo.pivotColumnId] = columnIdToColumnServiceMap[pivotColumnsInfo.pivotColumnId] as? StatusColumnService&#10;        }&#10;        val pulses = boardQueryResult.sectionsToPulsesMap.flatMap { it.value }&#10;        val info = $BOARD_VIEW$Info(&#10;                pulseIdToStatusColumnServiceMap = pulseIdToStatusColumnServiceMap,&#10;                pulses = pulses&#10;        )&#10;        nameColumnObservation?.invoke(info)&#10;    }&#10;}" description="add new board view" toReformat="false" toShortenFQNames="true">
    <variable name="BOARD_VIEW" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN_TOPLEVEL" value="true" />
    </context>
  </template>
  <template name="boardviewnew" value="import android.content.Context&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.FrameLayout&#10;import androidx.annotation.StringRes&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.*&#10;import com.dapulse.dapulse.R&#10;import com.dapulse.dapulse.refactor.layers.board_views.BoardViewToHostViewIsReadyEvent&#10;import com.dapulse.dapulse.refactor.layers.board_views.BoardViewsViewModel&#10;import com.dapulse.dapulse.refactor.layers.board_views.storage.BoardSubset&#10;import com.dapulse.dapulse.refactor.layers.board_views.storage.BoardViewPreferences&#10;import com.dapulse.dapulse.refactor.layers.columns.ColumnService&#10;import com.dapulse.dapulse.refactor.layers.columns.status.StatusColumnService&#10;import com.dapulse.dapulse.refactor.layers.columns.status.StatusColumnViewData&#10;import com.dapulse.dapulse.refactor.layers.data.board.*&#10;import com.dapulse.dapulse.refactor.layers.data.board.board_view_observer.IBoardViewObserver&#10;import com.dapulse.dapulse.refactor.layers.data.board.columns_view.OpenGallery&#10;import com.dapulse.dapulse.refactor.layers.data.board.columns_view.PulseInfo&#10;import com.dapulse.dapulse.refactor.tools.AppPerformanceMonitor&#10;import com.dapulse.dapulse.refactor.tools.db.MondayDatabase&#10;import com.google.gson.JsonObject&#10;import com.monday.boardViews.*&#10;import com.monday.boardViews.kanbanView.IStatusProvider&#10;import com.monday.core.BatteryWidget&#10;import com.monday.core.concurency.taskRunner.IOTaskRunner&#10;import com.monday.core.concurency.taskRunner.ITaskRunner&#10;import com.monday.core.concurency.taskRunner.MainThreadTaskRunner&#10;import com.monday.featureflag.featureFlagService.FeatureFlag&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.android.ContributesAndroidInjector&#10;import dagger.android.support.AndroidSupportInjection&#10;import kotlinx.android.synthetic.main.item_calendar_cell.*&#10;import kotlinx.coroutines.CoroutineDispatcher&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.*&#10;import java.util.*&#10;import javax.inject.Inject&#10;&#10;// TODO add $BOARD_VIEW$BoardViewFragmentModule::class to the module's list of the method bindBoardActivity&#10;// TODO add $BOARD_VIEW$($BOARD_VIEW$BoardViewProvider()) to BoardViewType enum&#10;// TODO add $BOARD_VIEW$_BOARD_VIEW_DEBUG(&quot;false&quot;) to RemoteConfigKey enum&#10;// TODO add $BOARD_VIEW$_VIEW to FeatureFlag enum&#10;// TODO add FeatureFlag.$BOARD_VIEW$_VIEW -&gt; { RemoteConfigKey.$BOARD_VIEW$_BOARD_VIEW_DEBUG } to method getStringValue of FeatureFlagService&#10;// TODO add FeatureFlag.$BOARD_VIEW$_VIEW -&gt; { remoteConfig.isEnabled(RemoteConfigKey.$BOARD_VIEW$_BOARD_VIEW_DEBUG) } to method isEnabled of FeatureFlagService&#10;// TODO add $BOARD_VIEW$_VIEW(&quot;$BOARD_VIEW$_view&quot;) to AppPerformanceMonitor.Component enum&#10;&#10;class $BOARD_VIEW$BoardViewProvider : IBoardViewProvider {&#10;&#10;    // This method provides the icon adn title that will be display in the board view picker&#10;    override fun getPickerInfo(): BoardViewPickerInfo {&#10;        return BoardViewPickerInfo(R.drawable.ic_icon_$BOARD_VIEW$, R.string.board_view_board_as_$BOARD_VIEW$_title, true)&#10;    }&#10;&#10;    // In case that the view depend on specific column and the column is missing, this method provides&#10;    // the icon, text and column type that will appear in the board view picker in the &quot;add column&quot; section,&#10;    // return here null means that the view is not depended on any specific column&#10;    override fun getPickerAddColumnInfo(existColumnServicesList: List&lt;ColumnService&gt;): BoardViewPickerAddColumnInfo? {&#10;        return null&#10;    }&#10;&#10;    // This method provides the fragment of the board view&#10;    override fun getFragment(): BoardViewFragment {&#10;        return $BOARD_VIEW$BoardViewFragment()&#10;    }&#10;&#10;    override fun getBoardViewTag(): String {&#10;        return &quot;$BOARD_VIEW$BoardViewFragment&quot;&#10;    }&#10;&#10;    // this will determine which action available in the Activity's FAB menu, if you want to get enable&#10;    // any action please see BoardViewsViewModel to look for the right live data to observe&#10;    override fun getHostConfiguration(): BoardViewHostConfiguration {&#10;        return BoardViewHostConfiguration(&#10;                enableAddItem = false,&#10;                enableAddColumn = false,&#10;                enableAddGroup = false&#10;        )&#10;    }&#10;&#10;    // this method gets the feature flag for the new board view, make sure to follow TODOs in order to&#10;    // add the new view to feature flag and to remote config&#10;    override fun getFeatureFlag(): FeatureFlag? {&#10;        return FeatureFlag.$BOARD_VIEW$_VIEW&#10;    }&#10;&#10;    // this method configure the board view navigation header, if you don't need it just return null&#10;    // the string resource in the text that will appear in the right action button&#10;    override fun getBoardViewInfoConfiguration(): BoardViewInfoConfiguration? {&#10;        return BoardViewInfoConfiguration(R.string.today)&#10;    }&#10;&#10;    // this method help to send performance events, make sure to follow TODOs in order to add the new&#10;    // component to AppPerformanceMonitor&#10;    override fun getPerformanceMonitorComponent(): AppPerformanceMonitor.Component {&#10;        return AppPerformanceMonitor.Component.$BOARD_VIEW$_VIEW&#10;    }&#10;&#10;    // this method configure what we showing the settings of the board view&#10;    // isSingleSelectedColumn - set whether the setting will be in single/multiple selection mode&#10;    // canShowColumnPredicate - set the list of columns that might be selected&#10;    // canPairColumnPredicate - set the list of columns that might be  connected, return false will leave empty list&#10;    override fun getBoardViewSettingsConfiguration(): BoardViewSettingsConfiguration? {&#10;        val canShowColumnPredictor: (ColumnService) -&gt; Boolean = { columnService -&gt; columnService is IStatusProvider }&#10;        val canPairColumnPredictor: (ColumnService) -&gt; Boolean = { false }&#10;        return BoardViewSettingsConfiguration(&#10;                isSingleSelectedColumn = false,&#10;                canShowColumnPredicate = canShowColumnPredictor,&#10;                canPairColumnPredicate = canPairColumnPredictor&#10;        )&#10;    }&#10;&#10;    // this method will hold the cross board configuration settings&#10;    override fun getCrossBoardCompositeConfiguration(): CrossBoardCompositeConfiguration {&#10;        return CrossBoardCompositeConfiguration(GroupBy.STATUS, true)&#10;    }&#10;&#10;    @StringRes&#10;    override fun getBoardViewDefaultName(): Int = R.string.board_view_$BOARD_VIEW$_title&#10;&#10;    override fun getBoardViewPreferences(&#10;            boardViewEntityModel: BoardViewEntityModel?,&#10;            boardSubsetModel: BoardSubset,&#10;            boardColumns: List&lt;JsonObject&gt;?&#10;    ): BoardViewPreferences? {&#10;        return BoardViewPreferences(boardId = boardSubsetModel.boardId,&#10;                viewId = boardViewEntityModel?.viewId ?: -1,&#10;                subsetId = boardSubsetModel.subsetId,&#10;                name = boardSubsetModel.name,&#10;                viewType = BoardViewType.$BOARD_VIEW$,&#10;                connectedColumnId = null,&#10;                columns = emptyList())&#10;    }&#10;}&#10;&#10;@Module&#10;abstract class $BOARD_VIEW$BoardViewFragmentModule {&#10;    @ContributesAndroidInjector(modules = [$BOARD_VIEW$BoardViewModule::class])&#10;    abstract fun bind$BOARD_VIEW$BoardViewFragment(): $BOARD_VIEW$BoardViewFragment&#10;&#10;    @Module&#10;    class $BOARD_VIEW$BoardViewModule {&#10;        @Provides&#10;        fun providePresenter(&#10;                fragment: $BOARD_VIEW$BoardViewFragment,&#10;                model: I$BOARD_VIEW$BoardViewModel,&#10;                viewModel: $BOARD_VIEW$BoardViewViewModel,&#10;                boardViewsViewModel: BoardViewsViewModel&#10;        ): I$BOARD_VIEW$BoardViewPresenter {&#10;            return $BOARD_VIEW$BoardViewPresenter(&#10;                    taskRunner = MainThreadTaskRunner(fragment.lifecycleScope),&#10;                    viewModel = viewModel,&#10;                    boardViewsViewModel = boardViewsViewModel,&#10;                    model = model&#10;            )&#10;        }&#10;&#10;        @Provides&#10;        fun provideModel(&#10;                crossBoardCompositeConfigure: IBoardViewsCrossBoardCompositeConfigure,&#10;                boardViewObserver: IBoardViewObserver&#10;        ): I$BOARD_VIEW$BoardViewModel {&#10;            return $BOARD_VIEW$BoardViewModel(&#10;                    boardViewObserver = boardViewObserver,&#10;                    crossBoardCompositeConfigure = crossBoardCompositeConfigure&#10;            )&#10;        }&#10;&#10;        @Provides&#10;        fun provideCrossBoardCompositeConfigure(&#10;                fragment: $BOARD_VIEW$BoardViewFragment,&#10;                mondayDatabase: MondayDatabase,&#10;                crossBoardComposite: ICrossBoardComposite,&#10;        ): IBoardViewsCrossBoardCompositeConfigure {&#10;            val boardId = fragment.arguments?.getLong(BOARD_ID, 1L) ?: 1L&#10;            return BoardViewsCrossBoardCompositeConfigure(&#10;                    crossBoardComposite = crossBoardComposite,&#10;                    boardId = boardId,&#10;                    boardViewType = BoardViewType.$BOARD_VIEW$,&#10;                    mondayDatabase = mondayDatabase,&#10;                    taskRunner = IOTaskRunner())&#10;        }&#10;&#10;        @Provides&#10;        fun provide$BOARD_VIEW$BoardViewViewModel(&#10;                fragment: $BOARD_VIEW$BoardViewFragment&#10;        ): $BOARD_VIEW$BoardViewViewModel {&#10;            return ViewModelProvider(fragment).get($BOARD_VIEW$BoardViewViewModel::class.java)&#10;        }&#10;&#10;        @Provides&#10;        fun provideBoardViewsViewModel(&#10;                fragment: $BOARD_VIEW$BoardViewFragment&#10;        ): BoardViewsViewModel {&#10;            // BoardViewsViewModel is common to all board views and board activity so it must be&#10;            // on the activity&#10;            return ViewModelProvider(fragment.requireActivity())&#10;                    .get(BoardViewsViewModel::class.java)&#10;        }&#10;    }&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewFragment : BoardViewFragment() {&#10;&#10;    @Inject&#10;    lateinit var presenter: I$BOARD_VIEW$BoardViewPresenter&#10;&#10;    override fun onAttach(context: Context) {&#10;        AndroidSupportInjection.inject(this)&#10;        super.onAttach(context)&#10;    }&#10;&#10;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {&#10;        val frameLayout = FrameLayout(requireContext())&#10;        frameLayout.setBackgroundColor(ContextCompat.getColor(requireContext(), R.color.da_white))&#10;        val battery = BatteryWidget(frameLayout.context)&#10;        val layoutParams = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 300)&#10;        layoutParams.setMargins(20, 0, 20, 0)&#10;        battery.layoutParams = layoutParams&#10;        battery.id = R.id.batteryBar&#10;        frameLayout.addView(battery)&#10;        return frameLayout&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        batteryBar.setOnClickListener {&#10;            presenter.onItemClick()&#10;        }&#10;        presenter.observe$BOARD_VIEW$ViewData(lifecycle) {&#10;            batteryBar.updateColorsCount(it.colorsCount)&#10;        }&#10;        presenter.loadData()&#10;    }&#10;}&#10;&#10;data class $BOARD_VIEW$ViewData(&#10;        val colorsCount: Map&lt;Int, Int&gt;,&#10;        val pulsesInfo: List&lt;PulseInfo&gt;&#10;)&#10;&#10;interface I$BOARD_VIEW$BoardViewViewObservers {&#10;    fun observe$BOARD_VIEW$ViewData(lifecycle: Lifecycle, observer: ($BOARD_VIEW$ViewData) -&gt; Unit)&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewViewModel : ViewModel(), I$BOARD_VIEW$BoardViewViewObservers {&#10;    private val viewDataLiveData = MutableLiveData&lt;$BOARD_VIEW$ViewData&gt;()&#10;&#10;    val currentViewData: $BOARD_VIEW$ViewData? get() = viewDataLiveData.value&#10;&#10;    override fun observe$BOARD_VIEW$ViewData(lifecycle: Lifecycle, observer: ($BOARD_VIEW$ViewData) -&gt; Unit) {&#10;        viewDataLiveData.observe({ lifecycle }) {&#10;            it?.let(observer)&#10;        }&#10;    }&#10;&#10;    fun update$BOARD_VIEW$ViewData(viewData: $BOARD_VIEW$ViewData) {&#10;        viewDataLiveData.postValue(viewData)&#10;    }&#10;}&#10;&#10;interface I$BOARD_VIEW$BoardViewPresenter : I$BOARD_VIEW$BoardViewViewObservers {&#10;    fun loadData()&#10;    fun onItemClick()&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewPresenter(&#10;        private val taskRunner: ITaskRunner,&#10;        private val viewModel: $BOARD_VIEW$BoardViewViewModel,&#10;        private val boardViewsViewModel: BoardViewsViewModel,&#10;        private val model: I$BOARD_VIEW$BoardViewModel&#10;) : I$BOARD_VIEW$BoardViewPresenter, I$BOARD_VIEW$BoardViewViewObservers by viewModel {&#10;&#10;    override fun loadData() {&#10;        taskRunner.run {&#10;            model.observeData().collect { info -&gt;&#10;                // set board view is ready when the board view has all data that it need in order to send&#10;                // view data, on first load of board activity loader will be shown until sending this event&#10;                if (viewModel.currentViewData == null) {&#10;                    boardViewsViewModel.setBoardViewToHostEvent(BoardViewToHostViewIsReadyEvent(BoardViewType.$BOARD_VIEW$))&#10;                }&#10;&#10;                val colorToCountMap = mutableMapOf&lt;Int, Int&gt;()&#10;                info.pulses.forEach {&#10;                    val viewData = info.pulseIdToStatusColumnServiceMap[it.columnId]?.getColumnValueViewData(it.pulseId)&#10;                    viewData?.getSpecificViewData&lt;StatusColumnViewData&gt;()?.color?.let { color -&gt;&#10;                        colorToCountMap[color] = (colorToCountMap[color] ?: 0) + 1&#10;                    }&#10;                }&#10;                viewModel.update$BOARD_VIEW$ViewData($BOARD_VIEW$ViewData(colorToCountMap, info.pulses.map { PulseInfo(it.pulseId, it.columnId) }))&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onItemClick() {&#10;        viewModel.currentViewData?.pulsesInfo?.firstOrNull()?.let {&#10;            val openGallery = OpenGallery(it.pulseId, BoardViewType.$BOARD_VIEW$.name.toLowerCase(Locale.getDefault()))&#10;            boardViewsViewModel.setOpenItem(openGallery)&#10;        }&#10;    }&#10;}&#10;&#10;data class $BOARD_VIEW$Info(&#10;        val pulseIdToStatusColumnServiceMap: Map&lt;String, StatusColumnService?&gt;,&#10;        val pulses: List&lt;GroupByInfo&gt;&#10;)&#10;&#10;interface I$BOARD_VIEW$BoardViewModel {&#10;    fun observeData(): Flow&lt;$BOARD_VIEW$Info&gt;&#10;}&#10;&#10;class $BOARD_VIEW$BoardViewModel(&#10;        private val boardViewObserver: IBoardViewObserver,&#10;        private val crossBoardCompositeConfigure: IBoardViewsCrossBoardCompositeConfigure,&#10;        private val dispatchers: CoroutineDispatcher = Dispatchers.Default&#10;) : I$BOARD_VIEW$BoardViewModel {&#10;&#10;    override fun observeData(): Flow&lt;$BOARD_VIEW$Info&gt; {&#10;        return boardViewObserver.observe(crossBoardCompositeConfigure)&#10;                .map { boardQueryResult -&gt;&#10;                    handleUpdateBoardQueryResult(boardQueryResult)&#10;                }.flowOn(dispatchers)&#10;    }&#10;&#10;    private fun handleUpdateBoardQueryResult(boardQueryResult: BoardQueryResult): $BOARD_VIEW$Info {&#10;        val columnIdToColumnServiceMap = boardQueryResult.columnsList.associateBy { it.id }&#10;        val pulseIdToStatusColumnServiceMap = mutableMapOf&lt;String, StatusColumnService?&gt;()&#10;        boardQueryResult.meta?.pivotColumnsList?.forEach { pivotColumnsInfo -&gt;&#10;            pulseIdToStatusColumnServiceMap[pivotColumnsInfo.pivotColumnId] = columnIdToColumnServiceMap[pivotColumnsInfo.pivotColumnId] as? StatusColumnService&#10;        }&#10;        val pulses = boardQueryResult.sectionsToPulsesMap.flatMap { it.value }&#10;        return $BOARD_VIEW$Info(&#10;                pulseIdToStatusColumnServiceMap = pulseIdToStatusColumnServiceMap,&#10;                pulses = pulses&#10;        )&#10;    }&#10;}" description="add new board view with board view observer" toReformat="false" toShortenFQNames="true">
    <variable name="BOARD_VIEW" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
</templateSet>